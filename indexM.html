<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Particle Heart ‚Äì Final with Floating Text</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    touch-action: none;
  }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>




/* =====================================================
   SCENE / CAMERA / RENDERER
===================================================== */
const scene = new THREE.Scene();
const worldGroup = new THREE.Group();
scene.add(worldGroup);

const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.set(0, 1.5, 7);
camera.lookAt(0, 1.2, 0);

let targetZoom = camera.position.z;
const minZoom = 1;
const maxZoom = 20;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* =====================================================
   CONSTANTS
===================================================== */
const COUNT = 15000;
const HEART_Y = 1.2;
const FORM_TIME = 5 * 60;

/* =====================================================
   HEART SHAPE
===================================================== */
function heartImplicit(x,y,z){
  return Math.pow(x*x+(9/4)*y*y+z*z-1,3)
       - x*x*z*z*z
       - (9/80)*y*y*z*z*z;
}

/* =====================================================
   HEART PARTICLES
===================================================== */
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const velocities = new Float32Array(COUNT * 3);
const heartTargets = new Float32Array(COUNT * 3);
const heartBase = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);

/* assign final heart position */
let hi = 0;
while (hi < COUNT) {
  const x=(Math.random()*2-1)*1.4;
  const y=(Math.random()*2-1)*1.4;
  const z=(Math.random()*2-1)*1.4;
  if (heartImplicit(x,y,z)<=0) {
    const hx = x * 1.5;
    const hy = z * 1.5 + HEART_Y;
    const hz = y * 1.5;
    heartTargets.set([hx,hy,hz], hi*3);
    heartBase.set([hx,hy,hz], hi*3);
    hi++;
  }
}

/* spawn same particles from bottom */
for (let i=0;i<COUNT;i++) {
  positions[i*3]   = (Math.random()*2-1)*6;
  positions[i*3+1] = -8 - Math.random()*4;
  positions[i*3+2] = (Math.random()*2-1)*6;

  velocities[i*3]   = 0;
  velocities[i*3+1] = 0.015 + Math.random()*0.01;
  velocities[i*3+2] = 0;

  colors.set([1.0, 0.75, 0.3], i*3);
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors,3));

/* =====================================================
   PARTICLE MATERIAL
===================================================== */
function makeCircleTexture(){
  const s = 256; // üî• much higher resolution
  const c = document.createElement('canvas');
  c.width = c.height = s;
  const ctx = c.getContext('2d');

  const g = ctx.createRadialGradient(
    s/2, s/2, 0,
    s/2, s/2, s/2
  );

  // üî• sharp bright core + wide soft glow
 g.addColorStop(0.00, 'rgba(255,255,255,01)');
 g.addColorStop(0.05, 'rgba(255,255,255,1)');
 g.addColorStop(0.12, 'rgba(255,255,255,0.9)');
 g.addColorStop(0.30, 'rgba(255,255,255,0.45)');
 g.addColorStop(0.60, 'rgba(255,255,255,0.25)');
 g.addColorStop(1.00, 'rgba(255,255,255,0)');

  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(s/2, s/2, s/2, 0, Math.PI * 2);
  ctx.fill();

  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.needsUpdate = true;
  return tex;
}


const heartParticles = new THREE.Points(
  geometry,
  new THREE.PointsMaterial({
    map: makeCircleTexture(),
    transparent: true,
    depthWrite: false,
    vertexColors: true,
    size: 0.1,                 // üî• larger glow footprint
    blending: THREE.AdditiveBlending,
    opacity: 0.9,               // üî• much brighter
    alphaTest: 0.1              // üî• crisp edge
  })
);
worldGroup.add(heartParticles);



/* =====================================================
   PLANE PARTICLES
===================================================== */
const PLANE_COUNT=10000, planeY=-1.3;
const planeGeometry=new THREE.BufferGeometry();
const planePos=new Float32Array(PLANE_COUNT*3);
const planeBase=new Float32Array(PLANE_COUNT*3);

for(let i=0;i<PLANE_COUNT;i++){
  const x=(Math.random()*2-1)*50;
  const z=(Math.random()*2-1)*50;
  planePos.set([x,planeY,z],i*3);
  planeBase.set([x,planeY,z],i*3);
}
planeGeometry.setAttribute('position',new THREE.BufferAttribute(planePos,3));

const planeParticles = new THREE.Points(
  planeGeometry,
  new THREE.PointsMaterial({
    map: makeCircleTexture(),
    color: 0xff3b3b,
    transparent: true,
    size: 0.3,
    opacity: 0
  })
);

let fadeInPlane = false;

setTimeout(()=>{
  worldGroup.add(planeParticles);

  fadeInPlane = true;
},2000);

/* =====================================================
   FLOATING TEXT (UNCHANGED)
===================================================== */
const words=[
  "Happy Valentine","I Love You","Always With You",
  "‚ù§Ô∏è","Be Mine", "My Love", "Sanjay"
];

const textSprites=[];

function createTextParticle(){
  const canvas=document.createElement('canvas');
  canvas.width=512; canvas.height=128;
  const ctx=canvas.getContext('2d');

  ctx.font='bold 60px Arial';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.fillStyle='#ff4d4d';
  ctx.shadowColor='rgba(255,80,80,0.9)';
  ctx.shadowBlur=20;

  const text=words[Math.floor(Math.random()*words.length)];
  ctx.fillText(text,256,64);

  const sprite=new THREE.Sprite(
    new THREE.SpriteMaterial({
      map:new THREE.CanvasTexture(canvas),
      transparent:true,
      opacity:0,
      depthWrite:false,
      depthTest:false
    })
  );

  sprite.scale.set(2.8,0.8,1);
  sprite.position.set(
    (Math.random()*2-1)*20,
    -10-Math.random()*5,
    (Math.random()*2-1)*20
  );

  sprite.userData={
    vx:(Math.random()-0.5)*0.01,
    vy:0.01+Math.random()*0.015,
    vz:(Math.random()-0.5)*0.01,
    delay:Math.random()*1.5
  };

  worldGroup.add(sprite);

  textSprites.push(sprite);
}
for(let i=0;i<80;i++) createTextParticle();

/* =====================================================
   NEW: RANDOM HEART BURST PARTICLES (ONLY WHEN BEATING)
===================================================== */
const miniHearts=[];

function createMiniHeart(){
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');

  ctx.clearRect(0,0,128,128);
  ctx.font = 'bold 64px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // üíó pink‚Äìred heart
  ctx.fillStyle = 'rgba(255,90,150,1)';
  ctx.shadowColor = 'rgba(255,90,150,1)';
  ctx.shadowBlur = 100;
  ctx.fillText('‚ù§Ô∏è', 64, 64);

  const sprite = new THREE.Sprite(
    new THREE.SpriteMaterial({
      map: new THREE.CanvasTexture(canvas),
      transparent: true,
      opacity: 0.8,                 // ‚úÖ 50% opacity
      depthWrite: false,
      depthTest: false,
      blending: THREE.AdditiveBlending
    })
  );

  sprite.scale.set(0.6, 0.6, 1);

  /* üåå RANDOM IN WHOLE 3D SPACE */
  sprite.position.set(
    (Math.random()*2 - 1) * 25,   // X space
    (Math.random()*2 - 1) * 15,   // Y space
    (Math.random()*2 - 1) * 25    // Z space
  );

  sprite.userData = {
    vx: (Math.random()-0.5) * 0.03,
    vy: (Math.random()-0.5) * 0.03,
    vz: (Math.random()-0.5) * 0.03,
    life: 3
  };

  scene.add(sprite);
  miniHearts.push(sprite);
}


/* =====================================================
   INTERACTION
===================================================== */
let dragging = false;
let lastX = 0, lastY = 0;
let lastTouchDist = 0;

/* ---------- ROTATION ---------- */
function rotate(dx, dy) {
  worldGroup.rotation.y += dx * 0.005;
  worldGroup.rotation.x += dy * 0.005;
}


/* ---------- MOUSE ---------- */
document.addEventListener('mousedown', e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});

document.addEventListener('mousemove', e => {
  if (!dragging) return;
  rotate(e.clientX - lastX, e.clientY - lastY);
  lastX = e.clientX;
  lastY = e.clientY;
});

document.addEventListener('mouseup', () => dragging = false);
document.addEventListener('mouseleave', () => dragging = false);

document.addEventListener('wheel', e => {
  e.preventDefault();
  targetZoom += e.deltaY * 0.005;
  targetZoom = Math.max(minZoom, Math.min(maxZoom, targetZoom));
}, { passive: false });

/* ---------- TOUCH ---------- */
document.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    dragging = true;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  }
  if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    lastTouchDist = Math.hypot(dx, dy);
  }
}, { passive: false });

document.addEventListener('touchmove', e => {
  e.preventDefault();

  // ‚òùÔ∏è Single finger rotate
  if (e.touches.length === 1 && dragging) {
    rotate(
      e.touches[0].clientX - lastX,
      e.touches[0].clientY - lastY
    );
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  }

  // ü§è Pinch zoom
  if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.hypot(dx, dy);

    targetZoom += (lastTouchDist - dist) * 0.01;
    targetZoom = Math.max(minZoom, Math.min(maxZoom, targetZoom));
    lastTouchDist = dist;
  }
}, { passive: false });

document.addEventListener('touchend', () => {
  dragging = false;
});


/* =====================================================
   HEART BEAT
===================================================== */
let beatTime=0;
const beatSpeed=1;
const beatStrength=0.02;

/* =====================================================
   ANIMATION LOOP
===================================================== */
let frame=0;
function animate(){
  requestAnimationFrame(animate);
  frame++;

  
  if(fadeInPlane && planeParticles.material.opacity<1){
    planeParticles.material.opacity+=0.01;
  }

  const progress=Math.min(frame/FORM_TIME,1);
  const p=geometry.attributes.position.array;
  const c=geometry.attributes.color.array;

  /* formation */
  if(progress<1){
    for(let i=0;i<COUNT;i++){
      const ix=i*3;
      velocities[ix+1]+=0.002*(1-progress);
      velocities[ix]+=(heartTargets[ix]-p[ix])*0.0015*progress;
      velocities[ix+1]+=(heartTargets[ix+1]-p[ix+1])*0.0015*progress;
      velocities[ix+2]+=(heartTargets[ix+2]-p[ix+2])*0.0015*progress;

      p[ix]+=velocities[ix];
      p[ix+1]+=velocities[ix+1];
      p[ix+2]+=velocities[ix+2];

      velocities[ix]*=0.97;
      velocities[ix+1]*=0.97;
      velocities[ix+2]*=0.97;

      c[ix]=1;
      c[ix+1]=0.75*(1-progress);
      c[ix+2]=0.3*(1-progress);
    }
  }

  /* heartbeat */
  if(progress>=1){
    beatTime+=0.03;

    // üî¥ spawn random mini hearts ONLY now
    if(Math.random()<0.9){
      createMiniHeart();
    }

    const s=1+Math.sin(beatTime*beatSpeed)*beatStrength;
    for(let i=0;i<COUNT;i++){
      p[i*3]=heartBase[i*3]*s;
      p[i*3+1]=(heartBase[i*3+1]-HEART_Y)*s+HEART_Y;
      p[i*3+2]=heartBase[i*3+2]*s;
    }
  }

  /* update mini hearts */
  for(let i=miniHearts.length-1;i>=0;i--){
    const m=miniHearts[i];
    m.position.x+=m.userData.vx;
    m.position.y+=m.userData.vy;
    m.position.z+=m.userData.vz;
    m.material.opacity*=0.95;

    if(m.userData.life<=0){
      scene.remove(m);
      miniHearts.splice(i,1);
    }
  }

  /* floating text */
  if(progress>=1){
    textSprites.forEach(s=>{
      if(s.userData.delay>0){
        s.userData.delay-=0.02;
        return;
      }
      s.material.opacity=Math.min(s.material.opacity+0.02,1);
      s.position.x+=s.userData.vx;
      s.position.y+=s.userData.vy;
      s.position.z+=s.userData.vz;
      if(s.position.y>8){
        s.position.set(
          (Math.random()*2-1)*20,
          -10-Math.random()*5,
          (Math.random()*2-1)*20
        );
        s.material.opacity=0;
        s.userData.delay=Math.random()*1.5;
      }
      s.lookAt(camera.position);
    });
  }

  camera.position.z+=(targetZoom-camera.position.z)*0.1;

  geometry.attributes.position.needsUpdate=true;
  geometry.attributes.color.needsUpdate=true;

  renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>
